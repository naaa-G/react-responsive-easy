[{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\__tests__\\ResponsiveProvider.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\__tests__\\ScalingEngine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\__tests__\\hooks.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\__tests__\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\hooks\\useBreakpoint.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\hooks\\useResponsiveValue.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[1534,1580],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":171,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":171,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5124,5175],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\hooks\\useScaledStyle.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[1876,1923],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3846,3905],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":184,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":184,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5830,5896],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\provider\\ResponsiveContext.tsx","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (222). Maximum allowed is 100.","line":33,"column":35,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":254,"endColumn":2}],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[2860,2942],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[3785,3867],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":122,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":122,"endColumn":23,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[4413,4484],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":149,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":149,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[5415,5474],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[8049,8370],"text":""},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useMemo, useCallback, useEffect, useState } from 'react';\r\nimport { ScalingEngine } from '../scaling/ScalingEngine';\r\nimport { \r\n  ResponsiveConfig, \r\n  ResponsiveContextValue, \r\n  Breakpoint, \r\n  ScaledValue, \r\n  ScaleOptions \r\n} from '../types';\r\n\r\n// Create the context with a default value\r\nconst ResponsiveContext = createContext<ResponsiveContextValue | null>(null);\r\n\r\n// Hook to use the responsive context\r\nexport const useResponsiveContext = () => {\r\n  const context = useContext(ResponsiveContext);\r\n  if (!context) {\r\n    throw new Error('useResponsiveContext must be used within a ResponsiveProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Props for the ResponsiveProvider\r\nexport interface ResponsiveProviderProps {\r\n  config: ResponsiveConfig;\r\n  // Optional: Override the current breakpoint for testing or SSR\r\n  initialBreakpoint?: Breakpoint | string;\r\n  // Optional: Enable debug mode\r\n  debug?: boolean;\r\n}\r\n\r\n// The main provider component  \r\nexport const ResponsiveProvider = ({\r\n  config,\r\n  initialBreakpoint,\r\n  debug = false,\r\n  children\r\n}: React.PropsWithChildren<ResponsiveProviderProps>) => {\r\n  // Create the scaling engine instance\r\n  const scalingEngine = useMemo(() => new ScalingEngine(config), [config]);\r\n  \r\n  // Resolve initial breakpoint\r\n  const resolvedInitialBreakpoint = useMemo(() => {\r\n    if (!initialBreakpoint) return config.base;\r\n    \r\n    // If initialBreakpoint is a string, find the matching breakpoint\r\n    if (typeof initialBreakpoint === 'string') {\r\n      const found = config.breakpoints.find(bp => \r\n        bp.name === initialBreakpoint || bp.alias === initialBreakpoint\r\n      );\r\n      return found ?? config.base;\r\n    }\r\n    \r\n    // If it's already a Breakpoint object, use it\r\n    return initialBreakpoint;\r\n  }, [initialBreakpoint, config.breakpoints, config.base]);\r\n\r\n  // State for current breakpoint\r\n  const [currentBreakpoint, setCurrentBreakpoint] = useState<Breakpoint>(\r\n    resolvedInitialBreakpoint\r\n  );\r\n  \r\n  // State for scaling ratios (pre-computed for performance)\r\n  const [scalingRatios, setScalingRatios] = useState<Record<string, number>>({});\r\n  \r\n  // State for computed values cache\r\n  const [computedValues, setComputedValues] = useState<Map<string, ScaledValue>>(new Map());\r\n  \r\n  // Pre-compute scaling ratios for all breakpoints\r\n  useEffect(() => {\r\n    const ratios: Record<string, number> = {};\r\n    config.breakpoints.forEach(breakpoint => {\r\n      try {\r\n        // Use a simple test value to get the ratio\r\n        const testResult = scalingEngine.scaleValue(100, breakpoint);\r\n        ratios[breakpoint.name] = testResult.ratio;\r\n      } catch (error) {\r\n        // Log error in development mode only\r\n        if (process.env.NODE_ENV === 'development') {\r\n          // eslint-disable-next-line no-console\r\n          console.warn(`Failed to compute ratio for breakpoint ${breakpoint.name}:`, error);\r\n        }\r\n      }\r\n    });\r\n    setScalingRatios(ratios);\r\n  }, [config.breakpoints, scalingEngine]);\r\n  \r\n  // Function to invalidate cache\r\n  const invalidateCache = useCallback(() => {\r\n    scalingEngine.clearCache();\r\n    setComputedValues(new Map());\r\n  }, [scalingEngine]);\r\n  \r\n  // Function to force re-computation\r\n  const forceRecompute = useCallback(() => {\r\n    invalidateCache();\r\n    // Re-compute ratios\r\n    const ratios: Record<string, number> = {};\r\n    config.breakpoints.forEach(breakpoint => {\r\n      try {\r\n        const testResult = scalingEngine.scaleValue(100, breakpoint);\r\n        ratios[breakpoint.name] = testResult.ratio;\r\n      } catch (error) {\r\n        // Log error in development mode only\r\n        if (process.env.NODE_ENV === 'development') {\r\n          // eslint-disable-next-line no-console\r\n          console.warn(`Failed to compute ratio for breakpoint ${breakpoint.name}:`, error);\r\n        }\r\n      }\r\n    });\r\n    setScalingRatios(ratios);\r\n  }, [config.breakpoints, scalingEngine, invalidateCache]);\r\n\r\n  // Enhanced scaling function that uses ScaleOptions\r\n  const scaleValueWithOptions = useCallback((value: number, options: ScaleOptions = {}): ScaledValue => {\r\n    try {\r\n      // Ensure we have a valid currentBreakpoint\r\n      if (!currentBreakpoint) {\r\n        // Log warning in development mode only\r\n        if (process.env.NODE_ENV === 'development') {\r\n          // eslint-disable-next-line no-console\r\n          console.warn('No current breakpoint available, using base breakpoint');\r\n        }\r\n        const result = scalingEngine.scaleValue(value, config.base, options);\r\n        return result;\r\n      }\r\n      \r\n      const result = scalingEngine.scaleValue(value, currentBreakpoint, options);\r\n      \r\n      // Cache the result if caching is enabled\r\n      if (!options.bypassCache) {\r\n        const cacheKey = `${value}-${currentBreakpoint.name}-${JSON.stringify(options)}`;\r\n        setComputedValues(prev => {\r\n          // Only update if the value is different\r\n          if (prev.get(cacheKey)?.scaled !== result.scaled) {\r\n            const newMap = new Map(prev);\r\n            newMap.set(cacheKey, result);\r\n            return newMap;\r\n          }\r\n          return prev;\r\n        });\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      // Log error in development mode only\r\n      if (process.env.NODE_ENV === 'development') {\r\n        // eslint-disable-next-line no-console\r\n        console.warn('Failed to scale value with options:', error);\r\n      }\r\n      // Return fallback value\r\n      return {\r\n        original: value,\r\n        scaled: value,\r\n        targetBreakpoint: currentBreakpoint || config.base,\r\n        ratio: 1,\r\n        constraints: {\r\n          minApplied: false,\r\n          maxApplied: false,\r\n          stepApplied: false\r\n        },\r\n        performance: {\r\n          computationTime: 0,\r\n          cacheHit: false\r\n        }\r\n      };\r\n    }\r\n  }, [scalingEngine, currentBreakpoint.name, currentBreakpoint.width, currentBreakpoint.height, config.base.name, config.base.width, config.base.height]);\r\n  \r\n  // Update current breakpoint based on viewport (only if no initialBreakpoint is provided)\r\n  useEffect(() => {\r\n    // If we have an initialBreakpoint, use it and don't set up viewport-based detection\r\n    if (initialBreakpoint) {\r\n      // Only update if the current breakpoint is different\r\n      if (currentBreakpoint.name !== resolvedInitialBreakpoint.name) {\r\n        setCurrentBreakpoint(resolvedInitialBreakpoint);\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Only set up viewport-based detection if no initialBreakpoint is provided\r\n    const updateBreakpoint = () => {\r\n      const width = window.innerWidth;\r\n      const height = window.innerHeight;\r\n      \r\n      // Find the best matching breakpoint\r\n      let bestMatch = config.base;\r\n      let bestScore = 0;\r\n      \r\n      config.breakpoints.forEach(breakpoint => {\r\n        // Calculate how well this breakpoint matches current viewport\r\n        const widthScore = 1 - Math.abs(width - breakpoint.width) / Math.max(width, breakpoint.width);\r\n        const heightScore = 1 - Math.abs(height - breakpoint.height) / Math.max(height, breakpoint.height);\r\n        const score = (widthScore + heightScore) / 2;\r\n        \r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n          bestMatch = breakpoint;\r\n        }\r\n      });\r\n      \r\n      setCurrentBreakpoint(bestMatch);\r\n    };\r\n    \r\n    // Initial update for dynamic detection\r\n    updateBreakpoint();\r\n    \r\n    // Listen for resize events to enable responsive behavior\r\n    const handleResize = () => {\r\n      updateBreakpoint();\r\n    };\r\n    \r\n    window.addEventListener('resize', handleResize);\r\n    \r\n    // Cleanup\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, [config.breakpoints, config.base, initialBreakpoint, resolvedInitialBreakpoint]);\r\n  \r\n  // Debug logging\r\n  useEffect(() => {\r\n    if (debug && process.env.NODE_ENV === 'development') {\r\n      // eslint-disable-next-line no-console\r\n      console.log('≡ƒöì ResponsiveProvider Debug:', {\r\n        currentBreakpoint,\r\n        scalingRatios,\r\n        cacheSize: computedValues.size,\r\n        config: {\r\n          base: config.base.name,\r\n          breakpoints: config.breakpoints.map(bp => bp.name),\r\n          strategy: config.strategy.origin\r\n        }\r\n      });\r\n    }\r\n  }, [debug, currentBreakpoint, scalingRatios, computedValues.size, config.base.name, config.breakpoints, config.strategy.origin]);\r\n  \r\n  // Create the context value\r\n  const contextValue: ResponsiveContextValue = useMemo(() => ({\r\n    config,\r\n    currentBreakpoint,\r\n    scalingRatios,\r\n    computedValues,\r\n    invalidateCache,\r\n    forceRecompute,\r\n    scaleValueWithOptions // Add the new scaling function\r\n  }), [config, currentBreakpoint, scalingRatios, computedValues, invalidateCache, forceRecompute, scaleValueWithOptions]);\r\n  \r\n  return (\r\n    <ResponsiveContext.Provider value={contextValue}>\r\n      {children}\r\n    </ResponsiveContext.Provider>\r\n  );\r\n};\r\n\r\n// Export the context for advanced usage\r\nexport { ResponsiveContext };\r\n","usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\scaling\\ScalingEngine.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'applyTokenScaling' has a complexity of 23. Maximum allowed is 15.","line":146,"column":28,"nodeType":"FunctionExpression","messageId":"complex","endLine":210,"endColumn":4},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.5.","line":229,"column":40,"nodeType":"Literal","messageId":"noMagic","endLine":229,"endColumn":43},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 0.5.","line":235,"column":33,"nodeType":"Literal","messageId":"noMagic","endLine":235,"endColumn":36},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: -2.","line":237,"column":26,"nodeType":"UnaryExpression","messageId":"noMagic","endLine":237,"endColumn":28}],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":157,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":157,"endColumn":21,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[4555,4639],"text":""},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ResponsiveConfig,\n  Breakpoint,\n  ScalingToken,\n  ScaledValue,\n  ScaleOptions,\n  PerformanceMetrics,\n  ScalingError\n} from '../types';\n\n/**\n * Core scaling engine that converts values between breakpoints\n * using mathematical precision and performance optimization\n */\nexport class ScalingEngine {\n  private config: ResponsiveConfig;\n  private cache: Map<string, ScaledValue>;\n  private performanceMetrics: PerformanceMetrics;\n  private scalingRatios: Map<string, number>;\n\n  constructor(config: ResponsiveConfig) {\n    this.config = config;\n    this.cache = new Map();\n    this.scalingRatios = new Map();\n    this.performanceMetrics = {\n      totalOperations: 0,\n      cacheHitRate: 0,\n      averageComputationTime: 0,\n      memoryUsage: 0,\n      peakMemoryUsage: 0\n    };\n\n    this.precomputeScalingRatios();\n  }\n\n  /**\n   * Pre-compute scaling ratios for all breakpoint combinations\n   * This dramatically improves performance for repeated calculations\n   */\n  private precomputeScalingRatios(): void {\n    const { base, breakpoints } = this.config;\n    \n    breakpoints.forEach(targetBreakpoint => {\n      const key = `${base.name}-${targetBreakpoint.name}`;\n      const ratio = this.calculateBaseRatio(base, targetBreakpoint);\n      this.scalingRatios.set(key, ratio);\n    });\n  }\n\n  /**\n   * Calculate the base scaling ratio between two breakpoints\n   * This is the foundation of all scaling calculations\n   */\n  private calculateBaseRatio(from: Breakpoint, to: Breakpoint): number {\n    const { origin } = this.config.strategy;\n    \n    switch (origin) {\n      case 'width':\n        return to.width / from.width;\n      \n      case 'height':\n        return to.height / from.height;\n      \n      case 'min':\n        return Math.min(to.width, to.height) / Math.min(from.width, from.height);\n      \n      case 'max':\n        return Math.max(to.width, to.height) / Math.max(from.width, from.height);\n      \n      case 'diagonal': {\n        const fromDiagonal = Math.sqrt(from.width ** 2 + from.height ** 2);\n        const toDiagonal = Math.sqrt(to.width ** 2 + to.height ** 2);\n        return toDiagonal / fromDiagonal;\n      }\n      \n      case 'area': {\n        const fromArea = from.width * from.height;\n        const toArea = to.width * to.height;\n        return toArea / fromArea;\n      }\n      \n      default:\n        throw new ScalingError(`Invalid scaling origin: ${origin}`, 'INVALID_CONFIG');\n    }\n  }\n\n  /**\n   * Scale a value from the base breakpoint to a target breakpoint\n   * This is the main public API for scaling values\n   */\n  public scaleValue(\n    value: number,\n    targetBreakpoint: Breakpoint,\n    options: ScaleOptions = {}\n  ): ScaledValue {\n    const startTime = performance.now();\n    \n    // Generate cache key\n    const cacheKey = this.generateCacheKey(value, targetBreakpoint, options);\n    \n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && !options.bypassCache) {\n      this.updatePerformanceMetrics(true, 0);\n      // Return cached result with updated performance metrics\n      return {\n        ...cached,\n        performance: {\n          ...cached.performance,\n          cacheHit: true\n        }\n      };\n    }\n\n    // Apply token-specific scaling rules if token is specified\n    const scaledValue = this.applyTokenScaling(value, targetBreakpoint, options);\n    \n    // Calculate the result\n    const result: ScaledValue = {\n      original: value,\n      scaled: scaledValue,\n      targetBreakpoint,\n      ratio: scaledValue / value,\n      constraints: this.getAppliedConstraints(value, scaledValue, options),\n      performance: {\n        computationTime: performance.now() - startTime,\n        cacheHit: false\n      }\n    };\n\n    // Cache the result\n    if (!options.bypassCache) {\n      this.cache.set(cacheKey, result);\n    }\n\n    // Update performance metrics\n    this.updatePerformanceMetrics(false, result.performance.computationTime);\n\n    return result;\n  }\n\n  /**\n   * Apply token-specific scaling rules using ScalingToken configuration\n   */\n  private applyTokenScaling(value: number, targetBreakpoint: Breakpoint, options: ScaleOptions): number {\n    if (!options.token) {\n      // No token specified, use default scaling\n      return this.calculateScaledValue(value, targetBreakpoint);\n    }\n\n    const tokenConfig: ScalingToken = this.config.strategy.tokens[options.token];\n    if (!tokenConfig) {\n      // Log warning in development mode only\n      if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.warn(`Token '${options.token}' not found in config, using default scaling`);\n      }\n      return this.calculateScaledValue(value, targetBreakpoint);\n    }\n\n    // First apply viewport-based scaling\n    let scaledValue = this.calculateScaledValue(value, targetBreakpoint);\n    \n    // Then apply token-specific scaling factor\n    let scaleFactor = typeof tokenConfig.scale === 'function' \n      ? tokenConfig.scale(this.getScalingRatio(targetBreakpoint))\n      : tokenConfig.scale;\n\n    // Override with options if provided\n    if (options.scale !== undefined) {\n      scaleFactor = options.scale;\n    }\n\n    // Apply the token scale factor to the viewport-scaled value\n    scaledValue = scaledValue * scaleFactor;\n\n    // Apply scaling curve for non-linear scaling\n    if (tokenConfig.curve && tokenConfig.curve !== 'linear') {\n      const ratio = this.getScalingRatio(targetBreakpoint);\n      scaledValue = this.applyScalingCurve(scaledValue, ratio, options);\n    }\n\n    // Apply constraints\n    if (tokenConfig.min !== undefined || options.min !== undefined) {\n      const minValue = options.min ?? tokenConfig.min ?? 0;\n      if (scaledValue < minValue) {\n        scaledValue = minValue;\n      }\n    }\n\n    if (tokenConfig.max !== undefined || options.max !== undefined) {\n      const maxValue = options.max ?? tokenConfig.max ?? Infinity;\n      if (scaledValue > maxValue) {\n        scaledValue = maxValue;\n      }\n    }\n\n    // Apply step increment if specified\n    if (tokenConfig.step !== undefined || options.step !== undefined) {\n      const step = options.step ?? tokenConfig.step ?? 1;\n      scaledValue = Math.round(scaledValue / step) * step;\n    }\n\n    // Apply precision\n    const precision = tokenConfig.precision ?? 1;\n    scaledValue = Math.round(scaledValue * Math.pow(10, precision)) / Math.pow(10, precision);\n\n    return scaledValue;\n  }\n\n  /**\n   * Apply scaling curve for non-linear scaling\n   */\n  private applyScalingCurve(\n    value: number,\n    ratio: number,\n    options: ScaleOptions\n  ): number {\n    if (!options.token) return value;\n\n    const tokenConfig = this.config.strategy.tokens[options.token];\n    if (!tokenConfig?.curve || tokenConfig.curve === 'linear') {\n      return value;\n    }\n\n    switch (tokenConfig.curve) {\n      case 'ease-in':\n        return value * Math.pow(ratio, 0.5);\n      \n      case 'ease-out':\n        return value * Math.pow(ratio, 2);\n      \n      case 'ease-in-out':\n        return value * (ratio < 0.5 \n          ? 2 * ratio * ratio \n          : 1 - Math.pow(-2 * ratio + 2, 2) / 2);\n      \n      case 'golden-ratio': {\n        const phi = 1.618033988749895;\n        return value * Math.pow(ratio, 1 / phi);\n      }\n      \n      default:\n        return value;\n    }\n  }\n\n  /**\n   * Get pre-computed scaling ratio for a target breakpoint\n   */\n  private getScalingRatio(targetBreakpoint: Breakpoint): number {\n    const key = `${this.config.base.name}-${targetBreakpoint.name}`;\n    const ratio = this.scalingRatios.get(key);\n    \n    if (ratio === undefined) {\n      throw new ScalingError(`No scaling ratio found for ${key}`, 'INVALID_BREAKPOINT');\n    }\n    \n    return ratio;\n  }\n\n  /**\n   * Calculate scaled value using the base scaling ratio\n   */\n  private calculateScaledValue(value: number, targetBreakpoint: Breakpoint): number {\n    const ratio = this.getScalingRatio(targetBreakpoint);\n    return value * ratio;\n  }\n\n  /**\n   * Get information about which constraints were applied\n   */\n  private getAppliedConstraints(original: number, scaled: number, options: ScaleOptions): ScaledValue['constraints'] {\n    const token = options.token ? this.config.strategy.tokens[options.token] : null;\n    \n    // Check if min constraint was applied\n    let minApplied = false;\n    if (token?.min !== undefined || options.min !== undefined) {\n      const minValue = options.min ?? token?.min ?? 0;\n      minApplied = scaled === minValue;\n    }\n    \n    // Check if max constraint was applied\n    let maxApplied = false;\n    if (token?.max !== undefined || options.max !== undefined) {\n      const maxValue = options.max ?? token?.max ?? Infinity;\n      maxApplied = scaled === maxValue;\n    }\n    \n    // Check if step constraint was applied\n    let stepApplied = false;\n    if (token?.step !== undefined || options.step !== undefined) {\n      const step = options.step ?? token?.step ?? 1;\n      stepApplied = scaled % step === 0;\n    }\n    \n    return {\n      minApplied,\n      maxApplied,\n      stepApplied\n    };\n  }\n\n  /**\n   * Generate cache key for storing/retrieving scaled values\n   */\n  private generateCacheKey(\n    value: number,\n    targetBreakpoint: Breakpoint,\n    options: ScaleOptions\n  ): string {\n    const parts = [\n      value.toString(),\n      targetBreakpoint.name,\n      options.token ?? 'default',\n      options.scale?.toString() ?? 'default',\n      options.min?.toString() ?? 'default',\n      options.max?.toString() ?? 'default',\n      options.step?.toString() ?? 'default'\n    ];\n    \n    return parts.join('|');\n  }\n\n  /**\n   * Update performance metrics\n   */\n  private updatePerformanceMetrics(cacheHit: boolean, computationTime: number): void {\n    this.performanceMetrics.totalOperations++;\n    \n    if (cacheHit) {\n      this.performanceMetrics.cacheHitRate = \n        (this.performanceMetrics.cacheHitRate * (this.performanceMetrics.totalOperations - 1) + 1) / \n        this.performanceMetrics.totalOperations;\n    } else {\n      this.performanceMetrics.cacheHitRate = \n        (this.performanceMetrics.cacheHitRate * (this.performanceMetrics.totalOperations - 1)) / \n        this.performanceMetrics.totalOperations;\n      \n      this.performanceMetrics.averageComputationTime = \n        (this.performanceMetrics.averageComputationTime * (this.performanceMetrics.totalOperations - 1) + computationTime) / \n        this.performanceMetrics.totalOperations;\n    }\n\n    // Update memory usage\n    const currentMemory = this.cache.size * 100; // Rough estimate\n    this.performanceMetrics.memoryUsage = currentMemory;\n    this.performanceMetrics.peakMemoryUsage = Math.max(\n      this.performanceMetrics.peakMemoryUsage,\n      currentMemory\n    );\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  public getPerformanceMetrics(): PerformanceMetrics {\n    return { ...this.performanceMetrics };\n  }\n\n  /**\n   * Clear the cache to free memory\n   */\n  public clearCache(): void {\n    this.cache.clear();\n    this.performanceMetrics.memoryUsage = 0;\n  }\n\n  /**\n   * Invalidate specific cache entries\n   */\n  public invalidateCache(pattern?: string): void {\n    if (!pattern) {\n      this.clearCache();\n      return;\n    }\n\n    for (const key of this.cache.keys()) {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Update configuration (useful for dynamic updates)\n   */\n  public updateConfig(newConfig: ResponsiveConfig): void {\n    this.config = newConfig;\n    this.scalingRatios.clear();\n    this.precomputeScalingRatios();\n    this.clearCache(); // Clear cache when config changes\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]},{"filePath":"H:\\Vs-Code\\react-responsive-easy\\packages\\core\\src\\utils\\defaultConfig.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'createDefaultConfig' has too many lines (103). Maximum allowed is 100.","line":7,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":109,"endColumn":2},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 8.","line":315,"column":51,"nodeType":"Literal","messageId":"noMagic","endLine":315,"endColumn":52},{"ruleId":"no-magic-numbers","severity":1,"message":"No magic number: 44.","line":319,"column":52,"nodeType":"Literal","messageId":"noMagic","endLine":319,"endColumn":54}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResponsiveConfig, Breakpoint, ScalingStrategy } from '../types';\r\n\r\n/**\r\n * Default configuration for React Responsive Easy\r\n * Provides sensible defaults that work for most applications\r\n */\r\nexport function createDefaultConfig(): ResponsiveConfig {\r\n  return {\r\n    base: {\r\n      name: 'desktop',\r\n      width: 1920,\r\n      height: 1080,\r\n      alias: 'base'\r\n    },\r\n    breakpoints: [\r\n      {\r\n        name: 'mobile',\r\n        width: 390,\r\n        height: 844,\r\n        alias: 'mobile'\r\n      },\r\n      {\r\n        name: 'tablet',\r\n        width: 768,\r\n        height: 1024,\r\n        alias: 'tablet'\r\n      },\r\n      {\r\n        name: 'laptop',\r\n        width: 1366,\r\n        height: 768,\r\n        alias: 'laptop'\r\n      },\r\n      {\r\n        name: 'desktop',\r\n        width: 1920,\r\n        height: 1080,\r\n        alias: 'base'\r\n      }\r\n    ],\r\n    strategy: {\r\n      origin: 'width',\r\n      mode: 'linear',\r\n      tokens: {\r\n        fontSize: {\r\n          scale: 0.85,\r\n          min: 12,\r\n          max: 48,\r\n          unit: 'px',\r\n          precision: 1,\r\n          responsive: true\r\n        },\r\n        spacing: {\r\n          scale: 0.9,\r\n          step: 2,\r\n          unit: 'px',\r\n          precision: 1,\r\n          responsive: true\r\n        },\r\n        radius: {\r\n          scale: 0.95,\r\n          min: 2,\r\n          unit: 'px',\r\n          precision: 1,\r\n          responsive: true\r\n        },\r\n        lineHeight: {\r\n          scale: 0.9,\r\n          min: 1.2,\r\n          unit: 'em',\r\n          precision: 0.1,\r\n          responsive: true\r\n        },\r\n        shadow: {\r\n          scale: 0.8,\r\n          unit: 'px',\r\n          precision: 1,\r\n          responsive: true\r\n        },\r\n        border: {\r\n          scale: 0.9,\r\n          min: 1,\r\n          unit: 'px',\r\n          precision: 1,\r\n          responsive: true\r\n        }\r\n      },\r\n      rounding: {\r\n        mode: 'nearest',\r\n        precision: 1\r\n      },\r\n      accessibility: {\r\n        minFontSize: 12,\r\n        minTapTarget: 44,\r\n        contrastPreservation: true\r\n      },\r\n      performance: {\r\n        memoization: true,\r\n        cacheStrategy: 'memory',\r\n        precomputeValues: true\r\n      }\r\n    },\r\n    development: {\r\n      enableDebugMode: false,\r\n      showScalingInfo: false,\r\n      logScalingCalculations: false\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Create a custom breakpoint with proper typing\r\n */\r\nexport function createBreakpoint(name: string, width: number, height: number, alias?: string): Breakpoint {\r\n  return {\r\n    name,\r\n    width,\r\n    height,\r\n    alias,\r\n    custom: {}\r\n  };\r\n}\r\n\r\n/**\r\n * Create a custom scaling strategy with proper typing\r\n */\r\nexport function createScalingStrategy(overrides: Partial<ScalingStrategy> = {}): ScalingStrategy {\r\n  const defaultStrategy: ScalingStrategy = {\r\n    origin: 'width',\r\n    mode: 'linear',\r\n    tokens: {\r\n      fontSize: {\r\n        scale: 0.85,\r\n        min: 12,\r\n        max: 48,\r\n        unit: 'px',\r\n        precision: 1,\r\n        responsive: true\r\n      },\r\n      spacing: {\r\n        scale: 0.9,\r\n        step: 2,\r\n        unit: 'px',\r\n        precision: 1,\r\n        responsive: true\r\n      },\r\n      radius: {\r\n        scale: 0.95,\r\n        min: 2,\r\n        unit: 'px',\r\n        precision: 1,\r\n        responsive: true\r\n      },\r\n      lineHeight: {\r\n        scale: 0.9,\r\n        min: 1.2,\r\n        unit: 'em',\r\n        precision: 0.1,\r\n        responsive: true\r\n      },\r\n      shadow: {\r\n        scale: 0.8,\r\n        unit: 'px',\r\n        precision: 1,\r\n        responsive: true\r\n      },\r\n      border: {\r\n        scale: 0.9,\r\n        min: 1,\r\n        unit: 'px',\r\n        precision: 1,\r\n        responsive: true\r\n      }\r\n    },\r\n    rounding: {\r\n      mode: 'nearest',\r\n      precision: 1\r\n    },\r\n    accessibility: {\r\n      minFontSize: 12,\r\n      minTapTarget: 44,\r\n      contrastPreservation: true\r\n    },\r\n    performance: {\r\n      memoization: true,\r\n      cacheStrategy: 'memory',\r\n      precomputeValues: true\r\n    }\r\n  };\r\n\r\n  return {\r\n    ...defaultStrategy,\r\n    ...overrides,\r\n    tokens: {\r\n      ...defaultStrategy.tokens,\r\n      ...overrides.tokens\r\n    },\r\n    rounding: {\r\n      ...defaultStrategy.rounding,\r\n      ...overrides.rounding\r\n    },\r\n    accessibility: {\r\n      ...defaultStrategy.accessibility,\r\n      ...overrides.accessibility\r\n    },\r\n    performance: {\r\n      ...defaultStrategy.performance,\r\n      ...overrides.performance\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration presets for common use cases\r\n */\r\nexport const configPresets = {\r\n  /**\r\n   * Conservative scaling - minimal changes between breakpoints\r\n   */\r\n  conservative: (config: ResponsiveConfig): ResponsiveConfig => ({\r\n    ...config,\r\n    strategy: {\r\n      ...config.strategy,\r\n      tokens: {\r\n        ...config.strategy.tokens,\r\n        fontSize: { ...config.strategy.tokens.fontSize, scale: 0.95 },\r\n        spacing: { ...config.strategy.tokens.spacing, scale: 0.95 },\r\n        radius: { ...config.strategy.tokens.radius, scale: 0.98 }\r\n      }\r\n    }\r\n  }),\r\n\r\n  /**\r\n   * Aggressive scaling - dramatic changes between breakpoints\r\n   */\r\n  aggressive: (config: ResponsiveConfig): ResponsiveConfig => ({\r\n    ...config,\r\n    strategy: {\r\n      ...config.strategy,\r\n      tokens: {\r\n        ...config.strategy.tokens,\r\n        fontSize: { ...config.strategy.tokens.fontSize, scale: 0.7 },\r\n        spacing: { ...config.strategy.tokens.spacing, scale: 0.75 },\r\n        radius: { ...config.strategy.tokens.radius, scale: 0.8 }\r\n      }\r\n    }\r\n  }),\r\n\r\n  /**\r\n   * Mobile-first approach - design for mobile, scale up\r\n   */\r\n  'mobile-first': (config: ResponsiveConfig): ResponsiveConfig => {\r\n    const mobileFirstConfig = { ...config };\r\n    \r\n    // Swap base to mobile\r\n    const mobileBreakpoint = config.breakpoints.find(bp => bp.alias === 'mobile');\r\n    const desktopBreakpoint = config.breakpoints.find(bp => bp.alias === 'base');\r\n    \r\n    if (mobileBreakpoint && desktopBreakpoint) {\r\n      mobileFirstConfig.base = mobileBreakpoint;\r\n      mobileFirstConfig.strategy.origin = 'width';\r\n      mobileFirstConfig.strategy.tokens.fontSize.scale = 1.2; // Scale up from mobile\r\n      mobileFirstConfig.strategy.tokens.fontSize.min = 14; // Larger minimum for mobile-first\r\n    }\r\n    \r\n    return mobileFirstConfig;\r\n  }\r\n};\r\n\r\n/**\r\n * Validate configuration and return any issues\r\n */\r\nexport function validateConfig(config: ResponsiveConfig): string[] {\r\n  const issues: string[] = [];\r\n\r\n  // Check base breakpoint exists\r\n  if (!config.base) {\r\n    issues.push('Base breakpoint is required');\r\n  }\r\n\r\n  // Check breakpoints array\r\n  if (!Array.isArray(config.breakpoints) || config.breakpoints.length === 0) {\r\n    issues.push('At least one breakpoint is required');\r\n  }\r\n\r\n  // Check base breakpoint is in breakpoints array\r\n  const baseInBreakpoints = config.breakpoints.some(bp => \r\n    bp.name === config.base.name || bp.alias === config.base.alias\r\n  );\r\n  if (!baseInBreakpoints) {\r\n    issues.push('Base breakpoint must be included in breakpoints array');\r\n  }\r\n\r\n  // Check for duplicate names\r\n  const names = config.breakpoints.map(bp => bp.name);\r\n  const uniqueNames = new Set(names);\r\n  if (names.length !== uniqueNames.size) {\r\n    issues.push('Breakpoint names must be unique');\r\n  }\r\n\r\n  // Check scaling strategy\r\n  if (!config.strategy) {\r\n    issues.push('Scaling strategy is required');\r\n  } else {\r\n    if (!['width', 'height', 'min', 'max', 'diagonal', 'area'].includes(config.strategy.origin)) {\r\n      issues.push('Invalid scaling origin');\r\n    }\r\n    \r\n    if (!['linear', 'exponential', 'logarithmic', 'golden-ratio', 'custom'].includes(config.strategy.mode)) {\r\n      issues.push('Invalid scaling mode');\r\n    }\r\n  }\r\n\r\n  // Check accessibility constraints\r\n  if (config.strategy.accessibility.minFontSize < 8) {\r\n    issues.push('Minimum font size should be at least 8px for accessibility');\r\n  }\r\n\r\n  if (config.strategy.accessibility.minTapTarget < 44) {\r\n    issues.push('Minimum tap target should be at least 44px for accessibility');\r\n  }\r\n\r\n  return issues;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"template-curly-spacing","replacedBy":[]},{"ruleId":"yield-star-spacing","replacedBy":[]},{"ruleId":"no-return-await","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]},{"ruleId":"wrap-iife","replacedBy":[]}]}]
